/**
 * @name theft-encoded
 * @description Query
 * @kind path-problem
 * @problem.severity error
 * @security-severity 10.0
 * @precision low
 * @id npm/epic-ue-fonts
 * @tags security
 *       malware
 */

import javascript
import DataFlow::PathGraph


// The malicious package was obfuscated using "JavaScript Obfuscator Tool" (https://obfuscator.io).
// A particular aspect of this tool is that it stores function names as strings in an array, which
// are retrieved during execution making it hard to statically analyze.

// The following query is just an attempt to capture this highly suspicious behaviour.


class TargetArray extends DataFlow::ArrayCreationNode {
    // CharPred
    TargetArray() {
        this.getAnElement().mayHaveStringValue("request")
    and this.getAnElement().mayHaveStringValue("write")
    and this.getAnElement().mayHaveStringValue("end")
    and this.getAnElement().mayHaveStringValue("POST")
    and this.getAnElement().mayHaveStringValue("env")
    }
}


// Taint-Tracking configuration for this problem
class ObfuscatorRequest_Configuration extends TaintTracking::Configuration {
    ObfuscatorRequest_Configuration() { this = "Obfuscator Request" }

    // Source: Array of Strings
    override predicate isSource(DataFlow::Node source) { source instanceof TargetArray }

    // Sink: Obfuscated HTTP Request
    override predicate isSink(DataFlow::Node sink) {
        exists( DataFlow::ModuleImportNode http, DataFlow::PropRead prop, DataFlow::Node node
              | http = DataFlow::moduleImport( [ "http", "https" ] )
            and http.flowsTo(node)
            and node = prop.getBase()
              | sink = prop.getPropertyNameExpr().flow()
              )
    }
}


// Taint-Tracking configuration for this problem
class ArrayParse_Configuration extends TaintTracking::Configuration {
    ArrayParse_Configuration() { this = "Array ParseInt" }

    // Source: Array of Strings
    override predicate isSource(DataFlow::Node source) { source instanceof TargetArray }

    // Sink: Applying 'parseInt' to some of the values
    override predicate isSink(DataFlow::Node sink) {
        exists( DataFlow::CallNode parse
              | parse.getCalleeName() = "parseInt"
              | parse.getAnArgument() = sink
              )
    }
}


from ObfuscatorRequest_Configuration cfg,
     DataFlow::PathNode source,
     DataFlow::PathNode sink,
     ArrayParse_Configuration parse_CFG
where cfg.hasFlowPath(source, sink)
  // Be sure that 'parseInt' gets applied to the array
  and parse_CFG.hasFlow(source.getNode(), _)
select sink.getNode(),
       source,
       sink,
       "$@ to $@",
       source.getNode(),
       "SOURCE",
       sink.getNode(),
       "SINK"
