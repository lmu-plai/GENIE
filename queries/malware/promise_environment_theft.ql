/**
 * @name promise_environment_theft
 * @description Query
 * @kind path-problem
 * @problem.severity error
 * @security-severity 9.0
 * @precision low
 * @id npm/sp-bootstrap
 * @tags security
 *       data
 *       taint
 */

import javascript
import DataFlow::PathGraph


// Taint-Tracking configuration for this problem
class VarENV_Configuration extends TaintTracking::Configuration {
    VarENV_Configuration() { this = "Environment Variables" }

    // Source: ENV Variables
    override predicate isSource(DataFlow::Node source) {
        source = DataFlow::globalVarRef("process").getAPropertyRead("env")
    }

    // Sink: ANY MethodCall
    override predicate isSink(DataFlow::Node sink) {
        exists( DataFlow::MethodCallNode methodCall
              | sink = methodCall.getAnArgument()
              )
    }

    override predicate isSanitizer(DataFlow::Node node) {
        exists( DataFlow::PropRead propRead, string s
              | propRead.accesses(node, s)
              | not exists( DataFlow::MethodCallNode method | method.calls(node, s) )
              )
    }
}


from VarENV_Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink, Write_Method write
where cfg.hasFlowPath(source, sink)
  and sink.getNode() = write.getAnArgument()
select sink.getNode(),
       source,
       sink,
       "$@ to $@",
       source.getNode(),
       "SOURCE",
       sink.getNode(),
       "SINK"


////////// Utilities //////////


// Apparently CodeQL doesn't like promises...
class ClientRequest_Promise extends ClientRequest::Range, DataFlow::MethodCallNode {

    ClientRequest client;

    // CharPred
    ClientRequest_Promise() { this.calls(client, "on") }

    override
    DataFlow::Node getUrl() { result = client.getUrl() }

    override
    DataFlow::Node getHost() { result = client.getHost() }

    override
    DataFlow::Node getADataNode() { result = client.getADataNode() }
}


// Taint-Tracking configuration for this problem
class ClientWrite_Configuration extends TaintTracking::Configuration {
    ClientWrite_Configuration() { this = "ClientRequest.write()" }

    // Source: ClientRequest
    override predicate isSource(DataFlow::Node source) {
        source instanceof ClientRequest
    }

    // Sink: Write MethodCall
    override predicate isSink(DataFlow::Node sink) {
        exists( DataFlow::MethodCallNode write
              | write.calls(sink, "write")
              )
    }
}


// Our target method: client.write(env)
class Write_Method extends DataFlow::MethodCallNode {
    Write_Method() {
        exists( ClientWrite_Configuration cfg, DataFlow::Node client
              | cfg.hasFlow(_, client)
              | this.calls(client, "write")
              )
    }
}
