/**
 * @name discord-injection
 * @description Query
 * @kind path-problem
 * @problem.severity error
 * @security-severity 10.0
 * @precision low
 * @id npm/blackice12/tiny
 * @tags security
 *       malware
 */

import javascript
import DataFlow::PathGraph


// Taint-Tracking configuration for this problem
class Discord_DOS_Configuration extends TaintTracking::Configuration {
    Discord_DOS_Configuration() { this = "Discord DOS" }

    // Source: Read of 'discord_voice'
    override predicate isSource(DataFlow::Node source) {
        exists( FileSystemReadAccess file_READ, TargetFile_CONCAT discord_PATH
              | discord_PATH = file_READ.getAPathArgument()
              | source = file_READ.getADataNode()
              )
        or
        exists( FileSystemReadAccess file_READ, TargetFile_STRING discord_PATH
              | discord_PATH = file_READ.getAPathArgument()
              | source = file_READ.getADataNode()
              )
    }

    // Sink: Write of 'discord_voice'
    override predicate isSink(DataFlow::Node sink) {
        exists( FileSystemWriteAccess file_WRITE, TargetFile_CONCAT discord_PATH
              | discord_PATH = file_WRITE.getAPathArgument()
              | sink = file_WRITE.getADataNode()
              )
        or
        exists( FileSystemWriteAccess file_WRITE, TargetFile_STRING discord_PATH
              | discord_PATH = file_WRITE.getAPathArgument()
              | sink = file_WRITE.getADataNode()
              )
    }
}


from Discord_DOS_Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink.getNode(),
       source,
       sink,
       "$@ to $@",
       source.getNode(),
       "SOURCE",
       sink.getNode(),
       "SINK"


////////// Utilities //////////


class TargetFile_CONCAT extends StringOps::Concatenation {

    StringOps::ConcatenationLeaf lastLeaf;

    // CharPred
    TargetFile_CONCAT() {
        lastLeaf = this.getLastLeaf()
        and
        exists( string s
              | lastLeaf.mayHaveStringValue(s)
              | s.matches( [ "%discord_voice\\index.js"
                           , "%discord_voice/index.js"
                           ]
                         )
              )
    }

}


class TargetFile_STRING extends DataFlow::Node {

    // CharPred
    TargetFile_STRING() {
        exists( string s
              | this.mayHaveStringValue(s)
              | s.matches( [ "%discord_voice\\index.js"
                           , "%discord_voice/index.js"
                           ]
                         )
              )
    }

}
